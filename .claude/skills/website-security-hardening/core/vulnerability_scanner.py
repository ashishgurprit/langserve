"""
Vulnerability detection module.

Scans for known vulnerabilities, CVEs, and common security issues.
"""

import re
from typing import List, Dict, Optional

# Import from scanners module (assumes parent directory is in path)
try:
    from scanners.base_scanner import (
        Vulnerability,
        SeverityLevel,
        NormalizedSecurityReport
    )
except ImportError:
    # Fallback for relative imports
    from ..scanners.base_scanner import (
        Vulnerability,
        SeverityLevel,
        NormalizedSecurityReport
    )


class VulnerabilityScanner:
    """
    Scans for security vulnerabilities.

    Checks for:
    - Known CVEs (if version detected)
    - Default credentials patterns
    - Exposed sensitive files
    - Weak encryption indicators
    """

    def __init__(self):
        """Initialize vulnerability scanner."""
        self.version = "1.0.0"

    def scan(self, report: NormalizedSecurityReport) -> List[Vulnerability]:
        """
        Scan for vulnerabilities in the security report.

        Args:
            report: Normalized security report

        Returns:
            List[Vulnerability]: Detected vulnerabilities
        """
        vulnerabilities = []

        # Scan for exposed sensitive files
        vulnerabilities.extend(self._scan_exposed_files(report))

        # Scan for weak encryption
        vulnerabilities.extend(self._scan_weak_encryption(report))

        # Scan for default credentials indicators
        vulnerabilities.extend(self._scan_default_credentials(report))

        # Scan for known CVEs (if version info available)
        if report.raw_data and 'versions' in report.raw_data:
            vulnerabilities.extend(self._scan_cves(report.raw_data['versions']))

        return vulnerabilities

    def _scan_exposed_files(self, report: NormalizedSecurityReport) -> List[Vulnerability]:
        """Scan for exposed sensitive files."""
        vulnerabilities = []

        # Check if raw_data contains exposed file information
        if not report.raw_data or 'exposed_files' not in report.raw_data:
            return vulnerabilities

        exposed = report.raw_data['exposed_files']

        for file_path in exposed:
            severity = SeverityLevel.CRITICAL

            # Determine severity based on file type
            if file_path.endswith(('.env', 'wp-config.php', 'config.php')):
                severity = SeverityLevel.CRITICAL
            elif file_path.endswith(('.sql', '.bak', '.backup')):
                severity = SeverityLevel.HIGH
            elif file_path.startswith('/.git/'):
                severity = SeverityLevel.HIGH
            else:
                severity = SeverityLevel.MEDIUM

            vulnerabilities.append(
                Vulnerability(
                    severity=severity,
                    title=f"Sensitive file exposed: {file_path}",
                    description=f"File is publicly accessible and may contain sensitive information",
                    affected_component="File Permissions",
                    remediation=f"Remove or restrict access to {file_path}",
                    references=["https://owasp.org/www-project-web-security-testing-guide/"]
                )
            )

        return vulnerabilities

    def _scan_weak_encryption(self, report: NormalizedSecurityReport) -> List[Vulnerability]:
        """Scan for weak encryption indicators."""
        vulnerabilities = []

        ssl_status = report.ssl_tls_status

        # Check for weak ciphers
        if 'cipher' in ssl_status:
            cipher = ssl_status['cipher']
            weak_patterns = ['RC4', 'MD5', 'DES', 'NULL', 'EXPORT', 'anon']

            if any(pattern in str(cipher) for pattern in weak_patterns):
                vulnerabilities.append(
                    Vulnerability(
                        severity=SeverityLevel.HIGH,
                        title="Weak cipher suite detected",
                        description=f"Server supports weak cipher: {cipher}",
                        affected_component="SSL/TLS Configuration",
                        remediation="Disable weak ciphers and use modern cipher suites (AES-GCM, ChaCha20)",
                        references=[
                            "https://wiki.mozilla.org/Security/Server_Side_TLS",
                            "https://ssl-config.mozilla.org/"
                        ]
                    )
                )

        # Check for outdated TLS protocol
        if 'protocol' in ssl_status:
            protocol = ssl_status['protocol']
            if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                vulnerabilities.append(
                    Vulnerability(
                        severity=SeverityLevel.HIGH,
                        title=f"Outdated TLS protocol: {protocol}",
                        description="Using deprecated TLS version vulnerable to known attacks",
                        affected_component="SSL/TLS Configuration",
                        cve_id="CVE-2014-3566" if protocol == 'SSLv3' else None,
                        remediation="Upgrade to TLS 1.2 or TLS 1.3",
                        references=["https://www.cve.org/CVERecord?id=CVE-2014-3566"]
                    )
                )

        return vulnerabilities

    def _scan_default_credentials(self, report: NormalizedSecurityReport) -> List[Vulnerability]:
        """Scan for default credentials indicators."""
        vulnerabilities = []

        # Check raw_data for default credential indicators
        if not report.raw_data:
            return vulnerabilities

        # Check for admin username
        if report.raw_data.get('admin_username') == 'admin':
            vulnerabilities.append(
                Vulnerability(
                    severity=SeverityLevel.HIGH,
                    title="Default admin username detected",
                    description="Using 'admin' as username makes brute force attacks easier",
                    affected_component="User Authentication",
                    remediation="Change admin username to something unique and non-obvious",
                    references=["https://owasp.org/www-project-top-ten/"]
                )
            )

        # Check for default database prefix (WordPress)
        if report.raw_data.get('db_prefix') == 'wp_':
            vulnerabilities.append(
                Vulnerability(
                    severity=SeverityLevel.MEDIUM,
                    title="Default database prefix detected",
                    description="Using default 'wp_' prefix makes SQL injection attacks easier",
                    affected_component="Database Configuration",
                    remediation="Change database prefix to something unique during installation",
                    references=["https://wordpress.org/support/article/hardening-wordpress/"]
                )
            )

        return vulnerabilities

    def _scan_cves(self, versions: Dict[str, str]) -> List[Vulnerability]:
        """
        Scan for known CVEs based on detected versions.

        Args:
            versions: Dict of component: version

        Returns:
            List[Vulnerability]: Known vulnerabilities
        """
        vulnerabilities = []

        # This is a simplified CVE database
        # In production, you would query a real CVE database or API
        known_vulns = self._get_known_vulnerabilities()

        for component, version in versions.items():
            component_lower = component.lower()

            if component_lower in known_vulns:
                for vuln_info in known_vulns[component_lower]:
                    if self._version_affected(version, vuln_info['affected_versions']):
                        vulnerabilities.append(
                            Vulnerability(
                                severity=vuln_info['severity'],
                                title=vuln_info['title'],
                                description=vuln_info['description'],
                                affected_component=f"{component} {version}",
                                cve_id=vuln_info.get('cve_id'),
                                remediation=vuln_info['remediation'],
                                references=vuln_info.get('references', [])
                            )
                        )

        return vulnerabilities

    def _get_known_vulnerabilities(self) -> Dict:
        """
        Get known vulnerabilities database.

        In production, this would query NVD, WPScan, or similar APIs.
        """
        return {
            'wordpress': [
                {
                    'title': 'WordPress Core - Multiple Vulnerabilities',
                    'description': 'WordPress versions below 6.4 contain multiple security vulnerabilities',
                    'affected_versions': ['<6.4'],
                    'severity': SeverityLevel.HIGH,
                    'cve_id': 'CVE-2023-XXXXX',
                    'remediation': 'Update WordPress to version 6.4 or higher',
                    'references': ['https://wordpress.org/news/category/security/']
                }
            ],
            'php': [
                {
                    'title': 'PHP - Remote Code Execution',
                    'description': 'PHP versions below 7.4 are end-of-life and vulnerable',
                    'affected_versions': ['<7.4'],
                    'severity': SeverityLevel.CRITICAL,
                    'cve_id': 'CVE-2023-XXXXX',
                    'remediation': 'Update PHP to version 8.0 or higher',
                    'references': ['https://www.php.net/supported-versions.php']
                }
            ],
            'apache': [
                {
                    'title': 'Apache - Path Traversal',
                    'description': 'Apache versions below 2.4.50 vulnerable to path traversal',
                    'affected_versions': ['<2.4.50'],
                    'severity': SeverityLevel.HIGH,
                    'cve_id': 'CVE-2021-41773',
                    'remediation': 'Update Apache to version 2.4.51 or higher',
                    'references': ['https://httpd.apache.org/security/vulnerabilities_24.html']
                }
            ]
        }

    def _version_affected(self, current: str, affected: List[str]) -> bool:
        """
        Check if current version is affected by vulnerability.

        Args:
            current: Current version string (e.g., "5.8.1")
            affected: List of affected version patterns (e.g., ["<6.0", ">=5.0,<5.9"])

        Returns:
            bool: True if version is affected
        """
        # Simplified version comparison
        # In production, use a proper version comparison library
        try:
            current_parts = [int(x) for x in current.split('.')[:3]]

            for pattern in affected:
                if pattern.startswith('<'):
                    threshold = pattern[1:].strip()
                    threshold_parts = [int(x) for x in threshold.split('.')[:3]]

                    if current_parts < threshold_parts:
                        return True

                elif pattern.startswith('>='):
                    # Handle range like ">=5.0,<5.9"
                    parts = pattern.split(',')
                    if len(parts) == 2:
                        min_ver = parts[0][2:].strip()
                        max_ver = parts[1][1:].strip()

                        min_parts = [int(x) for x in min_ver.split('.')[:3]]
                        max_parts = [int(x) for x in max_ver.split('.')[:3]]

                        if min_parts <= current_parts < max_parts:
                            return True

        except (ValueError, IndexError):
            # If version parsing fails, assume it might be affected
            return False

        return False
